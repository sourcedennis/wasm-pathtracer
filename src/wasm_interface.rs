// External imports
use wasm_bindgen::prelude::*;
use std::collections::HashMap;
use std::rc::Rc;
// Local imports
use crate::data::cap_stack::{Stack};
use crate::graphics::{Scene, MarchScene};
use crate::graphics::ray::{Ray, Tracable};
use crate::graphics::primitives::{Triangle};
use crate::graphics::{Mesh, Texture, Color3};
use crate::math::{Vec3};
use crate::math;
use crate::scenes::{setup_scene_cubesphere, setup_scene_bunny_low, setup_scene_bunny_high,
  setup_scene_cloud100, setup_scene_cloud10k, setup_scene_cloud100k, setup_scene_march};
use crate::tracer::{MatRefract, Camera, trace_original_color, trace_original_depth, trace_original_bvh};
use crate::marcher::{march_original_color, march_original_depth};
use crate::graphics::{Material};

// This file contains all the functions that are exposed through WebAssembly
// Interfacing with JavaScript is a bit annoying, as only primitives (i32, i64, f32, f64)
// can be passed across the "boundary".
// I purposefully avoid "bridging" JavaScript code that is generated by wasm-pack,
// because I'm unsure about performance penalties this may incur. So I write "simple bridges"
// with only primitives.

// The intuition about the tracing work is as follows:
// * This instance is initialised with session information (viewport, camera, ray depth, etc.)
// * This instance is *assigned* (by JavaScript) the pixels for which it should trace rays
//     (Thus JavaScript can spawn multiple webworkers - each with their own rays to compute)
// * The `compute` method is called, which traces the rays for all assigned pixels
//
// General notes:
// * Z points INTO the screen. -Z points to the eye

/// The "render type". This is the "type" of visuals that are displayed on the
/// screen.
enum RenderType {
  RenderColor, RenderDepth, RenderBVH
}

impl RenderType {
  /// Converts a "magic number" representing the type (obtained externally) into
  /// the proper `RenderType` element.
  fn from( u : u32 ) -> RenderType {
    match u {
      0 => RenderType::RenderColor,
      1 => RenderType::RenderDepth,
      2 => RenderType::RenderBVH,
      _ => RenderType::RenderColor
    }
  }
}

/// A scene can be either a ray-traced or ray-marched scene.
/// This enum distinguishes those.
enum SceneEnum {
  Trace( Scene ),
  March( MarchScene )
}

/// The state of a rendering session
///   (Sessions change upon framebuffer resize)
struct Config {
  // ## Global State
  meshes          : HashMap< u32, Mesh >,
  textures        : HashMap< u32, Texture >,

  // ## Session State
  viewport_width  : u32,
  viewport_height : u32,
  // True if rendering a depth buffer. Otherwise a color buffer
  render_type     : RenderType,
  resultbuffer    : Vec< u8 >,
  // Pixels that are handled by the renderer
  pixel_coords    : Vec< ( u32, u32 ) >,
  // Cached original rays
  rays            : Vec< Ray >,
  num_rays        : u32,
  scene_id        : u32,
  scene           : SceneEnum,
  max_ray_depth   : u32,
  camera          : Camera,

  // ## Preallocation Stuff
  // (avoids dynamic allocation)
  mat_stack       : Stack< MatRefract >,
}

/// This is global state, which it must be. WASM is called through
///   JS which owns the (global) state. Consider this whole WASM
///   module as a single encapsulated entity, with its own state.
static mut CONFIG : Option< Config > = None;

/// Initialises the *Session State*.
#[wasm_bindgen]
#[allow(dead_code)]
pub fn init( width : u32, height : u32, scene_id : u32, render_type : u32, max_ray_depth : u32
           , cam_x : f32, cam_y : f32, cam_z : f32, cam_rot_x : f32, cam_rot_y : f32 ) {
  unsafe {
    // Here is quite some code duplication, but this is hard to avoid as global state needs
    // to remain preserved. Doing this otherwise causes Rust to allocate a copy of this global
    // state, which is too expensive. (It contains all triangle meshes)
    if let Some( ref mut conf ) = CONFIG {
      // Preserve global state
      // ## Session State
      conf.viewport_width  = width;
      conf.viewport_height = height;
      conf.render_type     = RenderType::from( render_type );
      conf.resultbuffer    = vec![0; (width*height*4) as usize];
      conf.pixel_coords    = vec![(0,0); (width*height) as usize];
      conf.rays            = vec![Ray::new( Vec3::ZERO, Vec3::ZERO ); (width*height) as usize];
      conf.num_rays        = 0;
      conf.scene_id        = scene_id;
      conf.scene           = select_scene( scene_id, &conf.meshes, &conf.textures );
      conf.max_ray_depth   = max_ray_depth;
      conf.camera          = Camera::new( Vec3::new( cam_x, cam_y, cam_z ), cam_rot_x, cam_rot_y );

      // ## Preallocation Stuff
      conf.mat_stack       = Stack::new1( ( max_ray_depth + 1 ) as usize, MatRefract::AIR );
    } else {
      let meshes   = HashMap::new( );
      let textures = HashMap::new( );
      let scene    = select_scene( scene_id, &meshes, &textures );

      CONFIG = Some( Config {
        // ## Global State
        meshes
      , textures

        // ## Session State
      , viewport_width:   width
      , viewport_height:  height
      , render_type:      RenderType::from( render_type )
      , resultbuffer:     vec![0; (width*height*4) as usize]
        // Note that the actual pixels for this "thread" are distributed by JavaScript
      , pixel_coords:     vec![(0,0); (width*height) as usize]
      , rays:             vec![Ray::new( Vec3::ZERO, Vec3::ZERO ); (width*height) as usize]
      , num_rays:         0
      , scene_id
      , scene
      , max_ray_depth
      , camera:           Camera::new( Vec3::new( cam_x, cam_y, cam_z ), cam_rot_x, cam_rot_y )

        // ## Preallocation Stuff
      , mat_stack:        Stack::new1( ( max_ray_depth + 1 ) as usize, MatRefract::AIR )
      } );
    };
  }
}

/// Returns a pointer to the resulting buffer
/// This buffer is always of size `viewport_width * viewport_height`, but only the assigned
///   pixels are filled in.
#[wasm_bindgen]
#[allow(dead_code)]
pub fn results( ) -> *const u8 {
  unsafe {
    if let Some( ref conf ) = CONFIG {
      conf.resultbuffer.as_ptr( )
    } else {
      panic!( "init not called" )
    }
  }
}

// Called by JavaScript to obtain a pointer to the block in which the ray pixels are stored
// JavaScript fills it with the pixel locations that the raytracer should execute
//   (Such that pixels can be distributed over different workers running this raytracer)
#[wasm_bindgen]
#[allow(dead_code)]
pub fn ray_store( num_rays : u32 ) -> *mut (u32, u32) {
  unsafe {
    if let Some( ref mut conf ) = CONFIG {
      conf.num_rays = num_rays;
      conf.pixel_coords.as_mut_ptr( )
    } else {
      panic!( "init not called" )
    }
  }
}

// After JavaScript has assigned the pixels, the original rays are *precomputed*
// This improves performance when the camera does not move
#[wasm_bindgen]
#[allow(dead_code)]
pub fn ray_store_done( ) {
  unsafe {
    if let Some( ref conf ) = CONFIG {
      let origin = conf.camera.location;

      // For the camera:
      // - First rotate each direction around the x-axis
      // - Then rotate each direction around the y-axis
      // - Then translate the origin

      if let Some( ref mut conf ) = CONFIG {
        let fw = conf.viewport_width as f32;
        let fh = conf.viewport_height as f32;
        let w_inv = 1.0 / fw as f32;
        let h_inv = 1.0 / fh as f32;
        let ar = fw / fh;

        for i in 0..(conf.num_rays as usize) {
          let (x,y) = conf.pixel_coords[ i ];

          let fx = ( ( x as f32 + 0.5_f32 ) * w_inv - 0.5_f32 ) * ar;
          let fy = 0.5_f32 - ( y as f32 + 0.5_f32 ) * h_inv;

          let pixel = Vec3::new( fx, fy, 0.8 );
          let dir   = pixel.normalize( ).rot_x( conf.camera.rot_x ).rot_y( conf.camera.rot_y );

          conf.rays[ i ] = Ray::new( origin, dir );
        }
      }
    } else {
      panic!( "init not called" )
    }
  }
}

/// Updates the rendering session with new parameters
/// Other aspects of the session remain the same
#[wasm_bindgen]
#[allow(dead_code)]
pub fn update_params( render_type : u32, max_ray_depth : u32 ) {
  unsafe {
    if let Some( ref mut conf ) = CONFIG {
      conf.render_type   = RenderType::from( render_type );
      conf.max_ray_depth = max_ray_depth;
      conf.mat_stack     = Stack::new1( ( max_ray_depth + 1 ) as usize, MatRefract::AIR );
    } else {
      panic!( "init not called" )
    }
  }
}

/// Updates the rendered scene
/// Other aspects of the session remain the same
#[wasm_bindgen]
#[allow(dead_code)]
pub fn update_scene( scene_id : u32 ) {
  unsafe {
    if let Some( ref mut conf ) = CONFIG {
      conf.scene_id = scene_id;
      conf.scene    = select_scene( scene_id, &conf.meshes, &conf.textures );
    } else {
      panic!( "init not called" )
    }
  }
}

/// Updates the camera in the session
/// Other aspects of the session remain the same
/// Note that the camera first rotates around the x-axis, then around the y-axis, then it translates
#[wasm_bindgen]
#[allow(dead_code)]
pub fn update_camera( cam_x : f32, cam_y : f32, cam_z : f32, cam_rot_x : f32, cam_rot_y : f32 ) {
  unsafe {
    if let Some( ref mut conf ) = CONFIG {
      conf.camera = Camera::new( Vec3::new( cam_x, cam_y, cam_z ), cam_rot_x, cam_rot_y );
      ray_store_done( );
    } else {
      panic!( "init not called" )
    }
  }
}

// Mesh allocation happens in three stages:
// * First the space for the vertices is allocated
// * Then TypeScript stores the vertices in WASM's memory
// * Then, if the current scene is supposed to contain that mesh,
//     it is rebuilt with the mesh
//
// This is the first stage
#[wasm_bindgen]
#[allow(dead_code)]
pub fn allocate_mesh( id : u32, num_vertices : u32 ) {
  unsafe {
    if let Some( ref mut conf ) = CONFIG {
      conf.meshes.insert(
          id
        , Mesh::Preload( vec![Vec3::ZERO; num_vertices as usize] )
        );
    } else {
      panic!( "init not called" )
    }
  }
}

/// Obtains a pointer to the mesh vertices
#[wasm_bindgen]
#[allow(dead_code)]
pub fn mesh_vertices( id : u32 ) -> *mut Vec3 {
  unsafe {
    if let Some( ref mut conf ) = CONFIG {
      if let Some( Mesh::Preload( ref mut m ) ) = conf.meshes.get_mut( &id ) {
        m.as_mut_ptr( )
      } else {
        panic!( "Mesh not allocated" )
      }
    } else {
      panic!( "init not called" )
    }
  }
}

/// Notifies the raytracer that all the mesh vertices are placed in WASM
/// memory. Returns `true` if a scene with the loaded mesh is currently rendering
#[wasm_bindgen]
#[allow(dead_code)]
pub fn notify_mesh_loaded( id : u32 ) -> bool {
  unsafe {
    if let Some( ref mut conf ) = CONFIG {
      if let Some( Mesh::Preload( ref m ) ) = conf.meshes.get_mut( &id ) {
        let num_triangles = m.len( ) / 3;
        let mut triangles : Vec< Rc< dyn Tracable > > = Vec::with_capacity( num_triangles );

        let mat = Material::diffuse( Color3::new( 1.0, 0.4, 0.4 ) );

        for i in 0..num_triangles {
          // These are actually transformations within the scene
          // But do perform them here, instead of upon each scene construction
          let mut triangle =
            Triangle::new( m[ i * 3 + 0 ] * 0.5, m[ i * 3 + 1 ] * 0.5, m[ i * 3 + 2 ] * 0.5
                , mat.clone( ) );
          triangle = triangle.translate( Vec3::new( 0.0, 0.0, 5.0 ) );

          triangles.push( Rc::new( triangle ) );
        }

        conf.meshes.insert( id, Mesh::Triangled( triangles ) );
      }

      // Scene 1 uses mesh 0. Scene 2 uses mesh 1. Scene 3 uses mesh 2
      if ( id == 0 && conf.scene_id == 1 ) ||
         ( id == 1 && conf.scene_id == 2 ) ||
         ( id == 2 && conf.scene_id == 3 ) {
        conf.scene = select_scene( conf.scene_id, &conf.meshes, &conf.textures );
        true
      } else {
        false
      }
    } else {
      panic!( "init not called" )
    }
  }
}

/// Allocates a texture identifier by the provided `id` with the provided size
/// Returns a pointer to the u8 RGB store location
#[wasm_bindgen]
#[allow(dead_code)]
pub fn allocate_texture( id : u32, width : u32, height : u32 ) -> *mut (u8,u8,u8) {
  unsafe {
    if let Some( ref mut conf ) = CONFIG {
      conf.textures.insert(
          id
        , Texture::new( width, height )
        );
      if let Some( t ) = conf.textures.get_mut( &id ) {
        t.data.as_mut_ptr( )
      } else {
        // Shouldn't happen
        panic!( "HashMap error" )
      }
    } else {
      panic!( "init not called" )
    }
  }
}

/// Notifies the raytracer that the texture RGB data has been put into WASM's
/// memory. If the current scene is using that texture, the scene is updated
#[wasm_bindgen]
#[allow(dead_code)]
pub fn notify_texture_loaded( _id : u32 ) -> bool {
  unsafe {
    if let Some( ref mut _conf ) = CONFIG {
      false
    } else {
      panic!( "init not called" )
    }
  }
}

/// Rebuilds the BVH, and returns the number of nodes
#[wasm_bindgen]
#[allow(dead_code)]
pub fn rebuild_bvh( num_bins : u32, is_bvh4 : u32 ) -> u32 {
  unsafe {
    if let Some( ref mut conf ) = CONFIG {
      match conf.scene {
        SceneEnum::Trace( ref mut s ) =>
          s.rebuild_bvh( num_bins as usize, is_bvh4 != 0 ),
        // Marched scenes don't have a BVH (yet)
        SceneEnum::March( ref mut _s ) => 0
      }
    } else {
      panic!( "init not called" )
    }
  }
}

/// Disables the BVH
#[wasm_bindgen]
#[allow(dead_code)]
pub fn disable_bvh( ) {
  unsafe {
    if let Some( ref mut conf ) = CONFIG {
      match conf.scene {
        SceneEnum::Trace( ref mut s ) =>
          s.disable_bvh( ),
        // Marched scenes don't have a BVH (yet)
        SceneEnum::March( ref mut _s ) => { }
      }
    } else {
      panic!( "init not called" )
    }
  }
}

/// Actually traces all the rays
/// Note that it only traces rays whose pixels are assigned to this instance.
///   (in multi-threading different instances are assigned different pixels)
/// Returns the number of intersected BVH nodes
#[wasm_bindgen]
#[allow(dead_code)]
pub fn compute( ) -> u32 {
  unsafe {
    if let Some( ref mut conf ) = CONFIG {
      // These two loops are extracted (instead of checking for `is_depth` in the body),
      //   because I'm unsure whether the compiler hoists this. So, I hoist it.
      match conf.render_type {
        RenderType::RenderBVH   => compute_bvh( conf ),
        RenderType::RenderColor => compute_color( conf ),
        RenderType::RenderDepth => compute_depth( conf )
      }
    } else {
      panic!( "init not called" )
    }
  }
}

/// Traces rays to obtain a depth buffer of the scene (for assigned pixels)
/// Returns the number of intersected BVH nodes
fn compute_depth( conf : &mut Config ) -> u32 {
  match conf.scene {
    SceneEnum::Trace( ref s ) => {
      let mut u_sum = 0;
      for i in 0..(conf.num_rays as usize) {
        let (x, y) = conf.pixel_coords[ i ];

        let (u, res) = trace_original_depth( s, &conf.rays[ i ] );
        let v = 1.0 - math::clamp( ( res - 5.0 ) / 12.0, 0.0, 1.0 );

        conf.resultbuffer[ ( ( y * conf.viewport_width + x ) * 4 + 0 ) as usize ] = ( 255.0 * v ) as u8;
        conf.resultbuffer[ ( ( y * conf.viewport_width + x ) * 4 + 1 ) as usize ] = ( 255.0 * v ) as u8;
        conf.resultbuffer[ ( ( y * conf.viewport_width + x ) * 4 + 2 ) as usize ] = ( 255.0 * v ) as u8;
        conf.resultbuffer[ ( ( y * conf.viewport_width + x ) * 4 + 3 ) as usize ] = 255;

        u_sum += u;
      }
      u_sum as u32
    },
    SceneEnum::March( ref s ) => {
      for i in 0..(conf.num_rays as usize) {
        let (x, y) = conf.pixel_coords[ i ];

        let res = march_original_depth( s, &conf.rays[ i ] );

        conf.resultbuffer[ ( ( y * conf.viewport_width + x ) * 4 + 0 ) as usize ] = ( 255.0 * res.red ) as u8;
        conf.resultbuffer[ ( ( y * conf.viewport_width + x ) * 4 + 1 ) as usize ] = ( 255.0 * res.green ) as u8;
        conf.resultbuffer[ ( ( y * conf.viewport_width + x ) * 4 + 2 ) as usize ] = ( 255.0 * res.blue ) as u8;
        conf.resultbuffer[ ( ( y * conf.viewport_width + x ) * 4 + 3 ) as usize ] = 255;
      }
      0 // marching has no BVH. Yet?
    }
  }
}

/// Traces rays and, instead of diffuse colors, displays the number of BVH
///   intersections for the ray. 0-100 goes from green to blue. 100-200 goes
///   from blue to red. Anything above 200 is red.
/// The summed (over all rays) number of BVH hits is returned.
fn compute_bvh( conf : &mut Config ) -> u32 {
  match conf.scene {
    SceneEnum::Trace( ref s ) => {
      let mut d_sum : u32 = 0;

      for i in 0..(conf.num_rays as usize) {
        let (x, y) = conf.pixel_coords[ i ];

        let d = trace_original_bvh( s, &conf.rays[ i ] );
        let v = math::clamp( d as f32 / 200.0, 0.0, 1.0 );

        let res =
          if v < 0.5 { // blur from green to blue
            Color3::new( 0.0, 1.0 - v * 2.0, v * 2.0 )
          } else { // blur from blue to red
            Color3::new( ( v - 0.5 ) * 2.0, 0.0, 1.0 - ( v - 0.5 ) * 2.0 )
          };
        d_sum += d as u32;

        conf.resultbuffer[ ( ( y * conf.viewport_width + x ) * 4 + 0 ) as usize ] = ( 255.0 * res.red ) as u8;
        conf.resultbuffer[ ( ( y * conf.viewport_width + x ) * 4 + 1 ) as usize ] = ( 255.0 * res.green ) as u8;
        conf.resultbuffer[ ( ( y * conf.viewport_width + x ) * 4 + 2 ) as usize ] = ( 255.0 * res.blue ) as u8;
        conf.resultbuffer[ ( ( y * conf.viewport_width + x ) * 4 + 3 ) as usize ] = 255;
      }
      d_sum
    },
    SceneEnum::March( ref _s ) => {
      // Ray marching scenes have no BVH's (yet), so display all black
      for i in 0..(conf.num_rays as usize) {
        let (x, y) = conf.pixel_coords[ i ];

        conf.resultbuffer[ ( ( y * conf.viewport_width + x ) * 4 + 0 ) as usize ] = 0;
        conf.resultbuffer[ ( ( y * conf.viewport_width + x ) * 4 + 1 ) as usize ] = 0;
        conf.resultbuffer[ ( ( y * conf.viewport_width + x ) * 4 + 2 ) as usize ] = 0;
        conf.resultbuffer[ ( ( y * conf.viewport_width + x ) * 4 + 3 ) as usize ] = 255;
      }
      0 // No BVH for marching. Yet?
    }
  }
}

/// Traces rays to obtain a diffuse buffer of the scene (for assigned pixels)
/// It returns the number of BVH nodes hit
fn compute_color( conf : &mut Config ) -> u32 {
  let mat_stack = &mut conf.mat_stack;

  match conf.scene {
    SceneEnum::Trace( ref s ) => {
      let mut u_sum = 0;
      for i in 0..(conf.num_rays as usize) {
        let (x, y) = conf.pixel_coords[ i ];

        // Note that `mat_stack` already contains the "material" for air (so now it's a stack of air)
        let (u, res) = trace_original_color( s, &conf.rays[ i ], conf.max_ray_depth, mat_stack );

        conf.resultbuffer[ ( ( y * conf.viewport_width + x ) * 4 + 0 ) as usize ] = ( 255.0 * res.red ) as u8;
        conf.resultbuffer[ ( ( y * conf.viewport_width + x ) * 4 + 1 ) as usize ] = ( 255.0 * res.green ) as u8;
        conf.resultbuffer[ ( ( y * conf.viewport_width + x ) * 4 + 2 ) as usize ] = ( 255.0 * res.blue ) as u8;
        conf.resultbuffer[ ( ( y * conf.viewport_width + x ) * 4 + 3 ) as usize ] = 255;

        u_sum += u;
      }
      u_sum as u32
    },
    SceneEnum::March( ref s ) => {
      for i in 0..(conf.num_rays as usize) {
        let (x, y) = conf.pixel_coords[ i ];

        // Note that `mat_stack` already contains the "material" for air (so now it's a stack of air)
        let res = march_original_color( s, &conf.rays[ i ] );

        conf.resultbuffer[ ( ( y * conf.viewport_width + x ) * 4 + 0 ) as usize ] = ( 255.0 * res.red ) as u8;
        conf.resultbuffer[ ( ( y * conf.viewport_width + x ) * 4 + 1 ) as usize ] = ( 255.0 * res.green ) as u8;
        conf.resultbuffer[ ( ( y * conf.viewport_width + x ) * 4 + 2 ) as usize ] = ( 255.0 * res.blue ) as u8;
        conf.resultbuffer[ ( ( y * conf.viewport_width + x ) * 4 + 3 ) as usize ] = 255;
      }
      0 // No BVH for marching. Yet?
    }
  }
}

// Scenes are numbered in the interface. This functions performs the mapping
// Note that some scenes require externally obtained meshes, that's why these
//   are passed along as well
fn select_scene( id       : u32
               , meshes   : &HashMap< u32, Mesh >
               , _textures : &HashMap< u32, Texture >
               ) -> SceneEnum {
  match id {
    0 => SceneEnum::Trace( setup_scene_cubesphere( ) ),
    1 => SceneEnum::Trace( setup_scene_bunny_low( meshes ) ),
    2 => SceneEnum::Trace( setup_scene_bunny_high( meshes ) ),
    3 => SceneEnum::Trace( setup_scene_cloud100( meshes ) ),
    4 => SceneEnum::Trace( setup_scene_cloud10k( meshes ) ),
    5 => SceneEnum::Trace( setup_scene_cloud100k( meshes ) ),
    6 => SceneEnum::March( setup_scene_march( ) ),
    _ => panic!( "Invalid scene" )
  }
}
