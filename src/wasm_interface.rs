// External imports
use wasm_bindgen::prelude::*;
use std::collections::HashMap;
use std::rc::Rc;
use std::cell::RefCell;
// Local imports
use crate::graphics::{Scene};
use crate::graphics::ray::{Ray, Tracable};
use crate::graphics::primitives::{Triangle};
use crate::graphics::{Mesh, Texture, Color3};
use crate::math::{Vec3};
use crate::scenes::{setup_scene_cubesphere, setup_scene_bunny_low, setup_scene_bunny_high,
  setup_scene_cloud100, setup_scene_cloud10k, setup_scene_cloud100k};
use crate::tracer::{RenderInstance, RenderType, Camera};
use crate::graphics::{Material};
use crate::rng::Rng;
use crate::render_target::RenderTarget;

// This file contains all the functions that are exposed through WebAssembly
// Interfacing with JavaScript is a bit annoying, as only primitives (i32, i64, f32, f64)
// can be passed across the "boundary".
// I purposefully avoid "bridging" JavaScript code that is generated by wasm-pack,
// because I'm unsure about performance penalties this may incur. So I write "simple bridges"
// with only primitives.

// The intuition about the tracing work is as follows:
// * This instance is initialised with session information (viewport, camera, ray depth, etc.)
// * This instance is *assigned* (by JavaScript) the pixels for which it should trace rays
//     (Thus JavaScript can spawn multiple webworkers - each with their own rays to compute)
// * The `compute` method is called, which traces the rays for all assigned pixels
//
// General notes:
// * Z points INTO the screen. -Z points to the eye

/// The "render type". This is the "type" of visuals that are displayed on the
/// screen.
// enum RenderType {
//   RenderColor, RenderDepth, RenderBVH
// }

// impl RenderType {
//   /// Converts a "magic number" representing the type (obtained externally) into
//   /// the proper `RenderType` element.
//   fn from( u : u32 ) -> RenderType {
//     match u {
//       0 => RenderType::RenderColor,
//       1 => RenderType::RenderDepth,
//       2 => RenderType::RenderBVH,
//       _ => RenderType::RenderColor
//     }
//   }
// }

/// The state of a rendering session
///   (Sessions change upon framebuffer resize)
struct Config {
  // ## Global State
  meshes          : HashMap< u32, Mesh >,
  textures        : HashMap< u32, Texture >,
  rng             : Rc< RefCell< Rng > >,

  // ## Session State
  target          : Rc< RefCell< RenderTarget > >,
  //render_type     : RenderType,
  scene_id        : u32,
  scene           : Rc< RefCell< Scene > >,
  camera          : Rc< RefCell< Camera > >,

  left_instance   : RenderInstance,
  right_instance  : RenderInstance
}

/// This is global state, which it must be. WASM is called through
///   JS which owns the (global) state. Consider this whole WASM
///   module as a single encapsulated entity, with its own state.
static mut CONFIG : Option< Config > = None;

/// Initialises the *Session State*.
#[wasm_bindgen]
#[allow(dead_code)]
pub fn init( width : u32, height : u32, scene_id : u32, render_type : u32
           , cam_x : f32, cam_y : f32, cam_z : f32, cam_rot_x : f32, cam_rot_y : f32 ) {
  unsafe {
    // Here is quite some code duplication, but this is hard to avoid as global state needs
    // to remain preserved. Doing this otherwise causes Rust to allocate a copy of this global
    // state, which is too expensive. (It contains all triangle meshes)

    let left_width = ( width / 2 ) as usize;

    if let Some( ref mut conf ) = CONFIG {
      let scene            = Rc::new( RefCell::new( select_scene( scene_id, &conf.meshes, &conf.textures ) ) );
      let camera           = Rc::new( RefCell::new( Camera::new( Vec3::new( cam_x, cam_y, cam_z ), cam_rot_x, cam_rot_y ) ) );
      let target           = Rc::new( RefCell::new( RenderTarget::new( width as usize, height as usize ) ) );

      // Preserve global state
      // ## Session State
      conf.target          = target.clone( );
      //conf.render_type     = RenderType::from( render_type );
      conf.scene_id        = scene_id;
      conf.scene           = scene;
      conf.camera          = camera;
      conf.left_instance   = RenderInstance::new( conf.scene.clone( ), conf.camera.clone( ), conf.rng.clone( ), 0, 0, left_width, height as usize, target.clone( ), RenderType::Adaptive );
      conf.right_instance  = RenderInstance::new( conf.scene.clone( ), conf.camera.clone( ), conf.rng.clone( ), left_width, 0, width as usize - left_width, height as usize, target, RenderType::NormalNEE );
    } else {
      let meshes   = HashMap::new( );
      let textures = HashMap::new( );
      let scene    = Rc::new( RefCell::new( select_scene( scene_id, &meshes, &textures ) ) );
      let camera   = Rc::new( RefCell::new( Camera::new( Vec3::new( cam_x, cam_y, cam_z ), cam_rot_x, cam_rot_y ) ) );
      let target   = Rc::new( RefCell::new( RenderTarget::new( width as usize, height as usize ) ) );
      let rng      = Rc::new( RefCell::new( Rng::new( ) ) );

      let left_instance  = RenderInstance::new( scene.clone( ), camera.clone( ), rng.clone( ), 0, 0, left_width, height as usize, target.clone( ), RenderType::Adaptive );
      let right_instance = RenderInstance::new( scene.clone( ), camera.clone( ), rng.clone( ), left_width, 0, width as usize - left_width, height as usize, target.clone( ), RenderType::NormalNEE );

      CONFIG = Some( Config {
        // ## Global State
        meshes
      , textures
      , rng:              rng.clone( )

        // ## Session State
      //, render_type:      RenderType::from( render_type )
      , target
      , scene_id
      , scene:            scene.clone( )
      , camera

      , left_instance
      , right_instance
      } );
    };
  }
}

/// Returns a pointer to the resulting buffer
/// This buffer is of size `viewport_width * viewport_height`
#[wasm_bindgen]
#[allow(dead_code)]
pub fn results( ) -> *const u8 {
  unsafe {
    if let Some( ref conf ) = CONFIG {
      let target = conf.target.borrow( );
      target.results( ).as_ptr( )
    } else {
      panic!( "init not called" )
    }
  }
}

pub fn reset( ) {
  unsafe {
    if let Some( ref mut conf ) = CONFIG {
      let mut target = conf.target.borrow_mut( );
      target.clear( );
      conf.left_instance.reset( );
      conf.right_instance.reset( );
    } else {
      panic!( "init not called" )
    }
  }
}

/// Updates the rendering session with new parameters
/// Other aspects of the session remain the same
// #[wasm_bindgen]
// #[allow(dead_code)]
// pub fn update_params( render_type : u32, max_ray_depth : u32 ) {
//   unsafe {
//     if let Some( ref mut conf ) = CONFIG {
//       conf.render_type   = RenderType::from( render_type );
//       conf.mat_stack     = DefaultStack::new1( ( max_ray_depth + 1 ) as usize, MatRefract::AIR );
//     } else {
//       panic!( "init not called" )
//     }
//   }
// }

/// Updates the rendered scene
/// Other aspects of the session remain the same
#[wasm_bindgen]
#[allow(dead_code)]
pub fn update_scene( scene_id : u32 ) {
  unsafe {
    if let Some( ref mut conf ) = CONFIG {
      conf.scene_id             = scene_id;
      *conf.scene.borrow_mut( ) = select_scene( scene_id, &conf.meshes, &conf.textures );
      reset( );
    } else {
      panic!( "init not called" )
    }
  }
}

/// Updates the viewport, and thus the render buffer
#[wasm_bindgen]
#[allow(dead_code)]
pub fn update_viewport( width : u32, height : u32 ) {
  unsafe {
    if let Some( ref mut conf ) = CONFIG {
      *conf.target.borrow_mut( ) = RenderTarget::new( width as usize, height as usize );
      let left_width = width / 2;
      conf.left_instance.resize( 0, 0, left_width as usize, height as usize );
      conf.right_instance.resize( left_width as usize, 0, ( width - left_width ) as usize, height as usize );
      reset( );
    } else {
      panic!( "init not called" )
    }
  }
}

/// Updates the camera in the session
/// Other aspects of the session remain the same
/// Note that the camera first rotates around the x-axis, then around the y-axis, then it translates
#[wasm_bindgen]
#[allow(dead_code)]
pub fn update_camera( cam_x : f32, cam_y : f32, cam_z : f32, cam_rot_x : f32, cam_rot_y : f32 ) {
  unsafe {
    if let Some( ref mut conf ) = CONFIG {
      *conf.camera.borrow_mut( ) = Camera::new( Vec3::new( cam_x, cam_y, cam_z ), cam_rot_x, cam_rot_y );
      reset( );
    } else {
      panic!( "init not called" )
    }
  }
}

// Mesh allocation happens in three stages:
// * First the space for the vertices is allocated
// * Then TypeScript stores the vertices in WASM's memory
// * Then, if the current scene is supposed to contain that mesh,
//     it is rebuilt with the mesh
//
// This is the first stage
#[wasm_bindgen]
#[allow(dead_code)]
pub fn allocate_mesh( id : u32, num_vertices : u32 ) {
  unsafe {
    if let Some( ref mut conf ) = CONFIG {
      conf.meshes.insert(
          id
        , Mesh::Preload( vec![Vec3::ZERO; num_vertices as usize] )
        );
    } else {
      panic!( "init not called" )
    }
  }
}

/// Obtains a pointer to the mesh vertices
#[wasm_bindgen]
#[allow(dead_code)]
pub fn mesh_vertices( id : u32 ) -> *mut Vec3 {
  unsafe {
    if let Some( ref mut conf ) = CONFIG {
      if let Some( Mesh::Preload( ref mut m ) ) = conf.meshes.get_mut( &id ) {
        m.as_mut_ptr( )
      } else {
        panic!( "Mesh not allocated" )
      }
    } else {
      panic!( "init not called" )
    }
  }
}

/// Notifies the raytracer that all the mesh vertices are placed in WASM
/// memory. Returns `true` if a scene with the loaded mesh is currently rendering
#[wasm_bindgen]
#[allow(dead_code)]
pub fn notify_mesh_loaded( id : u32 ) -> bool {
  unsafe {
    if let Some( ref mut conf ) = CONFIG {
      if let Some( Mesh::Preload( ref m ) ) = conf.meshes.get_mut( &id ) {
        let num_triangles = m.len( ) / 3;
        let mut triangles : Vec< Rc< dyn Tracable > > = Vec::with_capacity( num_triangles );

        let mat = Material::diffuse( Color3::new( 1.0, 0.4, 0.4 ) );

        for i in 0..num_triangles {
          // These are actually transformations within the scene
          // But do perform them here, instead of upon each scene construction
          let mut triangle =
            Triangle::new( m[ i * 3 + 0 ] * 0.5, m[ i * 3 + 1 ] * 0.5, m[ i * 3 + 2 ] * 0.5
                , mat.clone( ) );
          triangle = triangle.translate( Vec3::new( 0.0, 0.0, 5.0 ) );

          triangles.push( Rc::new( triangle ) );
        }

        conf.meshes.insert( id, Mesh::Triangled( triangles ) );
      }

      // Scene 1 uses mesh 0. Scene 2 uses mesh 1. Scene 3 uses mesh 2
      if ( id == 0 && conf.scene_id == 1 ) ||
         ( id == 1 && conf.scene_id == 2 ) ||
         ( id == 2 && conf.scene_id == 3 ) {
        *conf.scene.borrow_mut( ) = select_scene( conf.scene_id, &conf.meshes, &conf.textures );
        reset( );
        true
      } else {
        false
      }
    } else {
      panic!( "init not called" )
    }
  }
}

/// Allocates a texture identifier by the provided `id` with the provided size
/// Returns a pointer to the u8 RGB store location
#[wasm_bindgen]
#[allow(dead_code)]
pub fn allocate_texture( id : u32, width : u32, height : u32 ) -> *mut (u8,u8,u8) {
  unsafe {
    if let Some( ref mut conf ) = CONFIG {
      conf.textures.insert(
          id
        , Texture::new( width, height )
        );
      if let Some( t ) = conf.textures.get_mut( &id ) {
        t.data.as_mut_ptr( )
      } else {
        // Shouldn't happen
        panic!( "HashMap error" )
      }
    } else {
      panic!( "init not called" )
    }
  }
}

/// Notifies the raytracer that the texture RGB data has been put into WASM's
/// memory. If the current scene is using that texture, the scene is updated
#[wasm_bindgen]
#[allow(dead_code)]
pub fn notify_texture_loaded( _id : u32 ) -> bool {
  unsafe {
    if let Some( ref mut _conf ) = CONFIG {
      false
    } else {
      panic!( "init not called" )
    }
  }
}

/// Actually traces the rays
/// Note that it only traces rays whose pixels are assigned to this instance.
///   (in multi-threading different instances are assigned different pixels)
/// Returns the number of intersected BVH nodes
#[wasm_bindgen]
#[allow(dead_code)]
pub fn compute( num_samples : usize ) {
  unsafe {
    if let Some( ref mut conf ) = CONFIG {
      let num_samples_left = num_samples / 2;
      conf.left_instance.compute( num_samples_left );
      conf.right_instance.compute( num_samples - num_samples_left );
    } else {
      panic!( "init not called" )
    }
  }
}

// Scenes are numbered in the interface. This functions performs the mapping
// Note that some scenes require externally obtained meshes, that's why these
//   are passed along as well
fn select_scene( id       : u32
               , meshes   : &HashMap< u32, Mesh >
               , _textures : &HashMap< u32, Texture >
               ) -> Scene {
  match id {
    0 => setup_scene_cubesphere( ),
    1 => setup_scene_bunny_low( meshes ),
    2 => setup_scene_bunny_high( meshes ),
    3 => setup_scene_cloud100( meshes ),
    4 => setup_scene_cloud10k( meshes ),
    5 => setup_scene_cloud100k( meshes ),
    6 => setup_scene_cubesphere( ),
    _ => panic!( "Invalid scene" )
  }
}
